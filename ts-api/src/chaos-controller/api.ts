/* tslint:disable */
/* eslint-disable */
/**
 * Dixa Testing Platform - OpenAPI 3.0
 * Platform for executing and monitoring Chaos experiments on the Dixa Test System, supporting the microservice-based system resiliency experimentation.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: ano@dixa.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * HTTPFaultInjection can be used to specify one or more faults to inject while forwarding HTTP requests to the destination specified in a route. Fault specification is part of a VirtualService rule. Faults include aborting the Http request from downstream service, and/or delaying proxying of requests. A fault rule MUST HAVE delay or abort or both.
 * @export
 * @interface IstioNetworkingV1alpha3HTTPFaultInjection
 */
export interface IstioNetworkingV1alpha3HTTPFaultInjection {
    /**
     * 
     * @type {IstioNetworkingV1alpha3HTTPFaultInjectionDelay}
     * @memberof IstioNetworkingV1alpha3HTTPFaultInjection
     */
    delay?: IstioNetworkingV1alpha3HTTPFaultInjectionDelay;
    /**
     * 
     * @type {IstioNetworkingV1alpha3HTTPFaultInjectionAbort}
     * @memberof IstioNetworkingV1alpha3HTTPFaultInjection
     */
    abort?: IstioNetworkingV1alpha3HTTPFaultInjectionAbort;
}
/**
 * @type IstioNetworkingV1alpha3HTTPFaultInjectionAbort
 * Abort specification is used to prematurely abort a request with a pre-specified error code. The following example will return an HTTP 400 error code for 1 out of every 1000 requests to the \"ratings\" service \"v1\".
 * @export
 */
export type IstioNetworkingV1alpha3HTTPFaultInjectionAbort = IstioNetworkingV1alpha3HTTPFaultInjectionAbortOneOf | IstioNetworkingV1alpha3HTTPFaultInjectionAbortOneOf1 | IstioNetworkingV1alpha3HTTPFaultInjectionAbortOneOf2 | object;

/**
 * 
 * @export
 * @interface IstioNetworkingV1alpha3HTTPFaultInjectionAbortOneOf
 */
export interface IstioNetworkingV1alpha3HTTPFaultInjectionAbortOneOf {
    /**
     * HTTP status code to use to abort the Http request.
     * @type {number}
     * @memberof IstioNetworkingV1alpha3HTTPFaultInjectionAbortOneOf
     */
    httpStatus: number;
}
/**
 * 
 * @export
 * @interface IstioNetworkingV1alpha3HTTPFaultInjectionAbortOneOf1
 */
export interface IstioNetworkingV1alpha3HTTPFaultInjectionAbortOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof IstioNetworkingV1alpha3HTTPFaultInjectionAbortOneOf1
     */
    grpcStatus: string;
}
/**
 * 
 * @export
 * @interface IstioNetworkingV1alpha3HTTPFaultInjectionAbortOneOf2
 */
export interface IstioNetworkingV1alpha3HTTPFaultInjectionAbortOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof IstioNetworkingV1alpha3HTTPFaultInjectionAbortOneOf2
     */
    http2Error: string;
}
/**
 * @type IstioNetworkingV1alpha3HTTPFaultInjectionDelay
 * Delay specification is used to inject latency into the request forwarding path. The following example will introduce a 5 second delay in 1 out of every 1000 requests to the \"v1\" version of the \"reviews\" service from all pods with label env: prod
 * @export
 */
export type IstioNetworkingV1alpha3HTTPFaultInjectionDelay = IstioNetworkingV1alpha3HTTPFaultInjectionDelayOneOf | IstioNetworkingV1alpha3HTTPFaultInjectionDelayOneOf1 | object;

/**
 * 
 * @export
 * @interface IstioNetworkingV1alpha3HTTPFaultInjectionDelayOneOf
 */
export interface IstioNetworkingV1alpha3HTTPFaultInjectionDelayOneOf {
    /**
     * Add a fixed delay before forwarding the request. Format: 1h/1m/1s/1ms. MUST be >=1ms.
     * @type {string}
     * @memberof IstioNetworkingV1alpha3HTTPFaultInjectionDelayOneOf
     */
    fixedDelay: string;
}
/**
 * 
 * @export
 * @interface IstioNetworkingV1alpha3HTTPFaultInjectionDelayOneOf1
 */
export interface IstioNetworkingV1alpha3HTTPFaultInjectionDelayOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof IstioNetworkingV1alpha3HTTPFaultInjectionDelayOneOf1
     */
    exponentialDelay: string;
}
/**
 * Percent specifies a percentage in the range of [0.0, 100.0].
 * @export
 * @interface IstioNetworkingV1alpha3Percent
 */
export interface IstioNetworkingV1alpha3Percent {
    /**
     * 
     * @type {number}
     * @memberof IstioNetworkingV1alpha3Percent
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    severity?: LogEntrySeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    timestamp?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum LogEntrySeverityEnum {
    Info = 'INFO',
    Fatal = 'FATAL'
}

/**
 * 
 * @export
 * @interface Run
 */
export interface Run {
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    testId?: string;
    /**
     * Status of the Test
     * @type {string}
     * @memberof Run
     */
    status?: RunStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    created_at?: string;
    /**
     * 
     * @type {Array<LogEntry>}
     * @memberof Run
     */
    logs?: Array<LogEntry>;
    /**
     * 
     * @type {RunResults}
     * @memberof Run
     */
    results?: RunResults;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    mode?: RunModeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RunStatusEnum {
    Scheduled = 'scheduled',
    Running = 'running',
    Stopped = 'stopped',
    Crashed = 'crashed',
    Completed = 'completed'
}
/**
    * @export
    * @enum {string}
    */
export enum RunModeEnum {
    Canary = 'canary',
    Production = 'production'
}

/**
 * 
 * @export
 * @interface RunResults
 */
export interface RunResults {
    /**
     * 
     * @type {string}
     * @memberof RunResults
     */
    status?: RunResultsStatusEnum;
    /**
     * 
     * @type {RunResultsUpstreamService}
     * @memberof RunResults
     */
    upstreamService?: RunResultsUpstreamService;
    /**
     * 
     * @type {RunResultsUpstreamService}
     * @memberof RunResults
     */
    downstreamService?: RunResultsUpstreamService;
}

/**
    * @export
    * @enum {string}
    */
export enum RunResultsStatusEnum {
    Pass = 'PASS',
    Fail = 'FAIL'
}

/**
 * 
 * @export
 * @interface RunResultsUpstreamService
 */
export interface RunResultsUpstreamService {
    /**
     * 
     * @type {string}
     * @memberof RunResultsUpstreamService
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RunResultsUpstreamService
     */
    logDump?: string;
}
/**
 * 
 * @export
 * @interface Test
 */
export interface Test {
    /**
     * 
     * @type {string}
     * @memberof Test
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Test
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Test
     */
    displayName?: string;
    /**
     * Description of a tests scenario.
     * @type {string}
     * @memberof Test
     */
    description?: string;
    /**
     * Name of the upstream source service from which traffic flows to the downstreamService.
     * @type {string}
     * @memberof Test
     */
    upstreamService?: string;
    /**
     * Name of the downstream target service to which traffic flows from the upstreamService.
     * @type {string}
     * @memberof Test
     */
    downstreamService?: string;
    /**
     * 
     * @type {TestSpec}
     * @memberof Test
     */
    spec?: TestSpec;
    /**
     * 
     * @type {TestSuccessCriterion}
     * @memberof Test
     */
    successCriterion?: TestSuccessCriterion;
}
/**
 * Chaos Test specification, defining perturbations to be injected into the system.
 * @export
 * @interface TestSpec
 */
export interface TestSpec {
    /**
     * 
     * @type {IstioNetworkingV1alpha3HTTPFaultInjection}
     * @memberof TestSpec
     */
    fault?: IstioNetworkingV1alpha3HTTPFaultInjection;
}
/**
 * Acceptance criterion for PASSing the test.
 * @export
 * @interface TestSuccessCriterion
 */
export interface TestSuccessCriterion {
    /**
     * 
     * @type {string}
     * @memberof TestSuccessCriterion
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TestSuccessCriterion
     */
    type?: TestSuccessCriterionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TestSuccessCriterion
     */
    service?: string;
    /**
     * 
     * @type {string}
     * @memberof TestSuccessCriterion
     */
    comparisonOperator?: TestSuccessCriterionComparisonOperatorEnum;
    /**
     * 
     * @type {number}
     * @memberof TestSuccessCriterion
     */
    threshold?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum TestSuccessCriterionTypeEnum {
    Latency = 'latency',
    Traffic = 'traffic',
    Errors = 'errors',
    Saturation = 'saturation',
    Availability = 'availability'
}
/**
    * @export
    * @enum {string}
    */
export enum TestSuccessCriterionComparisonOperatorEnum {
    GreaterThan = '>',
    LessThan = '<',
    Equal = '='
}


/**
 * RunsApi - axios parameter creator
 * @export
 */
export const RunsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new Run
         * @param {Run} run Create a new Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRun: async (run: Run, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'run' is not null or undefined
            assertParamExists('addRun', 'run', run)
            const localVarPath = `/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(run, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Append log entry to Run
         * @param {string} id ID of a Run
         * @param {LogEntry} logEntry Append log entry to Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendLog: async (id: string, logEntry: LogEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('appendLog', 'id', id)
            // verify required parameter 'logEntry' is not null or undefined
            assertParamExists('appendLog', 'logEntry', logEntry)
            const localVarPath = `/run/{id}/log`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Run
         * @param {string} id ID of a Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRun', 'id', id)
            const localVarPath = `/run/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Run
         * @param {string} id ID of a Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRun', 'id', id)
            const localVarPath = `/run/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Runs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuns: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Run
         * @param {string} id ID of a Run to patch
         * @param {Run} run Patch to be applied to the Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun: async (id: string, run: Run, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchRun', 'id', id)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('patchRun', 'run', run)
            const localVarPath = `/run/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(run, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunsApi - functional programming interface
 * @export
 */
export const RunsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new Run
         * @param {Run} run Create a new Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRun(run: Run, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRun(run, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Append log entry to Run
         * @param {string} id ID of a Run
         * @param {LogEntry} logEntry Append log entry to Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appendLog(id: string, logEntry: LogEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appendLog(id, logEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Run
         * @param {string} id ID of a Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRun(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRun(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Run
         * @param {string} id ID of a Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRun(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Run>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRun(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all Runs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRuns(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Run>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRuns(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch Run
         * @param {string} id ID of a Run to patch
         * @param {Run} run Patch to be applied to the Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRun(id: string, run: Run, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRun(id, run, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RunsApi - factory interface
 * @export
 */
export const RunsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new Run
         * @param {Run} run Create a new Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRun(run: Run, options?: any): AxiosPromise<void> {
            return localVarFp.addRun(run, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Append log entry to Run
         * @param {string} id ID of a Run
         * @param {LogEntry} logEntry Append log entry to Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendLog(id: string, logEntry: LogEntry, options?: any): AxiosPromise<void> {
            return localVarFp.appendLog(id, logEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Run
         * @param {string} id ID of a Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRun(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Run
         * @param {string} id ID of a Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(id: string, options?: any): AxiosPromise<Run> {
            return localVarFp.getRun(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Runs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuns(options?: any): AxiosPromise<Array<Run>> {
            return localVarFp.getRuns(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Run
         * @param {string} id ID of a Run to patch
         * @param {Run} run Patch to be applied to the Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(id: string, run: Run, options?: any): AxiosPromise<void> {
            return localVarFp.patchRun(id, run, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunsApi - object-oriented interface
 * @export
 * @class RunsApi
 * @extends {BaseAPI}
 */
export class RunsApi extends BaseAPI {
    /**
     * 
     * @summary Add a new Run
     * @param {Run} run Create a new Run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public addRun(run: Run, options?: any) {
        return RunsApiFp(this.configuration).addRun(run, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Append log entry to Run
     * @param {string} id ID of a Run
     * @param {LogEntry} logEntry Append log entry to Run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public appendLog(id: string, logEntry: LogEntry, options?: any) {
        return RunsApiFp(this.configuration).appendLog(id, logEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Run
     * @param {string} id ID of a Run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public deleteRun(id: string, options?: any) {
        return RunsApiFp(this.configuration).deleteRun(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Run
     * @param {string} id ID of a Run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public getRun(id: string, options?: any) {
        return RunsApiFp(this.configuration).getRun(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Runs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public getRuns(options?: any) {
        return RunsApiFp(this.configuration).getRuns(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Run
     * @param {string} id ID of a Run to patch
     * @param {Run} run Patch to be applied to the Run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsApi
     */
    public patchRun(id: string, run: Run, options?: any) {
        return RunsApiFp(this.configuration).patchRun(id, run, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestsApi - axios parameter creator
 * @export
 */
export const TestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new Test
         * @param {Test} test Create a new Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTest: async (test: Test, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'test' is not null or undefined
            assertParamExists('addTest', 'test', test)
            const localVarPath = `/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(test, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Test
         * @param {string} id ID of a Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTest: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTest', 'id', id)
            const localVarPath = `/test/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Test
         * @param {string} id ID of a Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTest: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTest', 'id', id)
            const localVarPath = `/test/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all tests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTests: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute test scenarios.
         * @param {string} id ID of the test to execute
         * @param {'canary' | 'production'} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTest: async (id: string, mode: 'canary' | 'production', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('runTest', 'id', id)
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('runTest', 'mode', mode)
            const localVarPath = `/test/{id}/run/{mode}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stops the test scenario immediately, in a Big Red Button fashion.
         * @param {string} id ID of the test to stop
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTest: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stopTest', 'id', id)
            const localVarPath = `/test/{id}/stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestsApi - functional programming interface
 * @export
 */
export const TestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new Test
         * @param {Test} test Create a new Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTest(test: Test, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTest(test, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Test
         * @param {string} id ID of a Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTest(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTest(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Test
         * @param {string} id ID of a Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTest(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Test>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTest(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all tests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTests(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Test>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTests(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Execute test scenarios.
         * @param {string} id ID of the test to execute
         * @param {'canary' | 'production'} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runTest(id: string, mode: 'canary' | 'production', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runTest(id, mode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stops the test scenario immediately, in a Big Red Button fashion.
         * @param {string} id ID of the test to stop
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopTest(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopTest(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TestsApi - factory interface
 * @export
 */
export const TestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new Test
         * @param {Test} test Create a new Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTest(test: Test, options?: any): AxiosPromise<void> {
            return localVarFp.addTest(test, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Test
         * @param {string} id ID of a Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTest(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTest(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Test
         * @param {string} id ID of a Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTest(id: string, options?: any): AxiosPromise<Test> {
            return localVarFp.getTest(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all tests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTests(options?: any): AxiosPromise<Array<Test>> {
            return localVarFp.getTests(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute test scenarios.
         * @param {string} id ID of the test to execute
         * @param {'canary' | 'production'} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runTest(id: string, mode: 'canary' | 'production', options?: any): AxiosPromise<void> {
            return localVarFp.runTest(id, mode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stops the test scenario immediately, in a Big Red Button fashion.
         * @param {string} id ID of the test to stop
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTest(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.stopTest(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestsApi - object-oriented interface
 * @export
 * @class TestsApi
 * @extends {BaseAPI}
 */
export class TestsApi extends BaseAPI {
    /**
     * 
     * @summary Add a new Test
     * @param {Test} test Create a new Test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public addTest(test: Test, options?: any) {
        return TestsApiFp(this.configuration).addTest(test, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Test
     * @param {string} id ID of a Test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public deleteTest(id: string, options?: any) {
        return TestsApiFp(this.configuration).deleteTest(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Test
     * @param {string} id ID of a Test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getTest(id: string, options?: any) {
        return TestsApiFp(this.configuration).getTest(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all tests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public getTests(options?: any) {
        return TestsApiFp(this.configuration).getTests(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute test scenarios.
     * @param {string} id ID of the test to execute
     * @param {'canary' | 'production'} mode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public runTest(id: string, mode: 'canary' | 'production', options?: any) {
        return TestsApiFp(this.configuration).runTest(id, mode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stops the test scenario immediately, in a Big Red Button fashion.
     * @param {string} id ID of the test to stop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestsApi
     */
    public stopTest(id: string, options?: any) {
        return TestsApiFp(this.configuration).stopTest(id, options).then((request) => request(this.axios, this.basePath));
    }
}


